1.
a) 
customPow(x, n)
	for i = 0 - > n
		x *= x;
	return x;
fiind o functie nerecursiva cu un singur for de la 1 la n, 
aceasta functie are complexitate Theta(n)

b)
customPow(x, n)
	if n == 0
		return 1;

	else
		return x * customPow(x, n-1);
	
Complexitatea acestui algoritm este Theta(n) deoarece functia 
este apelata recursiv de n ori, iar complexitatea codului din 
functie este Theta(1)
T(n) = Theta(1) + T(n-1)
T(n-1) = Theta(1) + T(n-2)
T(n-2) = Theta(1) + T(n-3)...

T(n-k) = Theta(1) + T(n-k-1)...

T(n-h) = Theta(1) + T(1)
h = n-1 - > Complexitatea este Theta(n)

c)
customPow(x, n)
	if n == 0
		return 1;
	else if n > 0
		if n % 2 == 0
			y = customPow(n/2);
			return y*y;
		else
			y = customPow(x, (n-1)/2);
			return x * y * y;
T(n) = T(n/2) + Theta(1)

2.
a)
fib(n)
	if n == 0
		return 0;
	if n == 1
		return 1;
	if n > 1 
		return fib(n-1) + fib(n+1)

b)
fib(n)
	temp1 = 0;
	temp2 = 1;
	sum = 0;
	if n == 0 || n == 1
		return n;
	for i = 2 -> n
		sum = temp1 + temp2;
		temp1 = temp2;
		temp2 = sum;
	return sum;

Fiin un singur loop, complexitatea este Theta(n)
		